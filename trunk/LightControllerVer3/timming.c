/*
timming.c
Implement timming functions
Date created: 04/19/2007
*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include "timming.h"
//#include "lcd_8_bit.h"
#include "sysComm.h"
#include "diskio.h"

static volatile unsigned int tick = 0,tick1=0;//,tick3 = 0;
static volatile unsigned char tick2 = 0;
volatile unsigned int SOAPtimer = 0;

void initTimer0(){       //Used Timer0		
	/*
	TCNT0 = 25;         //255 - 230   1 milisecond  
	TIMSK |= 0x01;      //Timer0 overflow interrupt enable   
	TCCR0 = 0x04;       //Start Timer0, Fclk = Fxtal/64 = 230400 Hz
	resetTime();*/
	ASSR=0x00;
	TCCR0=0x0C;			//Start Timer0, Fclk = Fxtal/64 = 230400 Hz
	TCNT0=0x00;
	OCR0 = 230;         // 0 --> 230 in 1.000 milisecond
	TIMSK |= 0x02;      //Timer0 output compare  match interrupt enable  
	resetTime();

}
/*
void initTimer2(void){
	// Timer 2
	TCCR2=0x0D;
	TCNT2=0x00;
	OCR2=0x90;
	TIMSK |= 0x80;     //Timer 2 output compare  match interrupt enable  
}*/
//---------------------------
void delayMs(unsigned int ms){

	tick1 = 0;
	while(tick1 < ms);

}
//---------------------------
unsigned int getTime(){
	return tick;
}
//---------------------------
void resetTime(void){
	tick = 0;
}
/*
//---------------------------
unsigned int getRealtimeFailure(void){
	return tick3;
}
//---------------------------
void resetRealtimeFailure(void){
	tick3 = 0;
}
*/
//---------------------------
void delay(unsigned long time){
	//unsigned char i=0;
	while(time--){
		asm("NOP");
	}
}
//---------------------------
void Delay(unsigned int time){
	unsigned int i,j;
	for(i=0;i<time;i++){
		for(j=0;j<time;j++){
		  asm("NOP");
		}
	}
}
//Timer2 used for ModBus

void timer2_init(void)
{  
    TCCR2 = 0x00;  // stop 
    TCNT2 = 0x01;  // setup    
    TIMSK |= 0x40; //overflow interrupt enable
    
}
void CLEAR_MB_TIME(void){
	TCCR2 = 0x00;   //  Stop Timer 2
	TCNT2 = 0x01;   //  Clear thanh ghi counter
}
void START_MB_TIME15(void){//1.5 ms
	TCNT2 = 168;  // 1.5 ms to overflow
	TCCR2 = 0x04;  // start timer2 with 57600 kHz clock 
}
void START_MB_TIME2(void){//2.0 ms
	TCNT2 = 140;   // 2.0 ms to overflow
	TCCR2 = 0x04;  // start timer2 with 57600 kHz clock 
}
void START_MB_TIME35(void){//3.5 ms
	TCNT2 = 53;    // 3.5 ms to overflow
	TCCR2 = 0x04;  // start timer2 with 57600 kHz clock 
}
/*
//Timer1 used for ModBus
void timer1_init(void)
{  
    TCCR1B = 0x00;  // stop 
    TCCR1A = 0x00;  
    TCNT1H = 0x00;  // setup
    TCNT1L = 0x01;     
    //ICR1   = 220;
    //TCCR1A = 0x02;  // Fast PWM, TOP = ICR1       
    //TCCR1B = 0x13;  // start Timer f_clk = 230.400 kHz
    TIMSK |= 0x04;
    
}
void CLEAR_MB_TIME(void){
	TCCR1B = 0x00;  //  Stop Timer 1
	TCCR1A = 0x00;  
	TCNT1H = 0x00;  //  Clear thanh ghi counter
	TCNT1L = 0x01;
	//TIMSK &= (~0x04);
}
void START_MB_TIME15(void){//1.5 ms
	ICR1H  = 0x01;
	ICR1L  = 0x5B;  // 347
	TCCR1A = 0x02;  // Fast PWM, TOP = ICR1  
	TCCR1B = 0x13;  // start Timer f_clk = 230.400 kHz
	//TIMSK |= 0x04;
}
void START_MB_TIME2(void){//2.0 ms
	ICR1H  = 0x01;
	ICR1L  = 0xCE;  // 462
	TCCR1A = 0x02;  // Fast PWM, TOP = ICR1  
	TCCR1B = 0x13;  // start Timer f_clk = 230.400 kHz
	//TIMSK |= 0x04;
}
void START_MB_TIME35(void){//3.5 ms
	ICR1H  = 0x03;
	ICR1L  = 0x29;  // 809
	TCCR1A = 0x02;  // Fast PWM, TOP = ICR1  
	TCCR1B = 0x13;  // start Timer f_clk = 230.400 kHz
	//TIMSK |= 0x04;
}
*/
//--------------------------
ISR(SIG_OUTPUT_COMPARE0){  // 1ms
     
    tick++;  //for getTime()
    tick1++; //for delayMs()
	tick2++; //for SD Card Module
	//tick3++; //for check Ds1307
	SOAPtimer++;
	if (tick == 0xffff){
		tick = 0;
	} 
	if(tick2 >= 10){        // 100Hz timer interrupt generated by OC0   
		tick2 = 0;
		disk_timerproc();	// Drive timer procedure of low level disk I/O module 
	}
}

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/

/*
ISR(TIMER2_COMP_vect)
{
	//Timer++;			// Performance counter for this module 
	disk_timerproc();	// Drive timer procedure of low level disk I/O module 
} */

